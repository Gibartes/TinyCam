<!doctype html>
<html lang="en">
<!-- ===== SVG icon sprite ===== -->
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
  <!-- Play -->
  <symbol id="ico-play" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <polygon points="8 5 19 12 8 19 8 5"></polygon>
  </symbol>
  <!-- Stop -->
  <symbol id="ico-stop" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <rect x="6" y="6" width="12" height="12" rx="2"></rect>
  </symbol>
  <!-- Record -->
  <symbol id="ico-record" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0">
    <circle cx="12" cy="12" r="6"></circle>
  </symbol>
  <!-- Download -->
  <symbol id="ico-download" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <path d="M7 10l5 5 5-5"></path><path d="M12 15V3"></path>
  </symbol>
  <!-- Upload -->
  <symbol id="ico-upload" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <path d="M7 10l5-5 5 5"></path><path d="M12 5v12"></path>
  </symbol>
  <!-- Save -->
  <symbol id="ico-save" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2Z"/>
    <path d="M17 21V13H7v8"/><path d="M7 3v6h8"/>
  </symbol>
  <!-- Trash -->
  <symbol id="ico-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <polyline points="3 6 5 6 21 6"></polyline>
    <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
    <path d="M10 11v6M14 11v6"></path>
  </symbol>
  <!-- Broom -->
  <symbol id="ico-broom" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M3 21l6-6"/><path d="M15 7l6-6"/><path d="M6 18c3 1 6-2 7-3l2-2c1-1 4-4 3-7"/>
  </symbol>
  <!-- Wrench -->
  <symbol id="ico-wrench" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M10.5 7A5.5 5.5 0 1 0 17 13.5L21 17.5 17.5 21 13.5 17a5.5 5.5 0 0 0-3-10z"/>
  </symbol>
  <!-- Scroll -->
  <symbol id="ico-scroll" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M7 4h10a2 2 0 0 1 2 2v12H9a2 2 0 0 1-2-2V4z"/><path d="M7 8h12"/><path d="M7 12h12"/>
  </symbol>
  <!-- Theme icons -->
  <symbol id="ico-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="4"></circle>
    <path d="M12 2v2M12 20v2M20 12h2M2 12H4M18.36 5.64l1.41-1.41M4.23 19.78l1.41-1.41M18.36 18.36l1.41 1.41M4.23 4.22l1.41 1.41"/>
  </symbol>
  <symbol id="ico-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
  </symbol>
</svg>

<head>
  <meta charset="utf-8" />
  <title>TinyCam WebView - Foldable Sidebar + Secure Key + REC Stats</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }

    /* ================= THEME TOKENS ================= */
    :root {
      /* Dark (default) */
      --bg: #0b0b0b;
      --fg: #e5e7eb;
      --muted: #9ca3af;

      --card: #141518;
      --card-2: #101010;
      --sidebar: #0f1012;

      --border: #ffffff1a;
      --border-soft: #0002;

      --btn: #17191e;
      --btn-hover: #1a1c21;

      --accent: #3b82f6;
      --danger: #ef4444;

      --video-bg: #000;
      --log-bg: #0b0b0b;
      --input-bg: #111;
    }
    :root.theme-light {
      /* Light */
      --bg: #f8fafc;
      --fg: #0f172a;
      --muted: #475569;

      --card: #ffffff;
      --card-2: #ffffff;
      --sidebar: #ffffff;

      --border: #0000001a;
      --border-soft: #0000001a;

      --btn: #f4f6f9;
      --btn-hover: #eef2ff;

      --accent: #2563eb;
      --danger: #dc2626;

      --video-bg: #000;
      --log-bg: #ffffff;
      --input-bg: #ffffff;
    }

    html, body { height:100%; }
    body {
      margin:0; min-height:100vh; display:flex; flex-direction:column;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", sans-serif;
      background: var(--bg); color: var(--fg);
    }

    /* Top bar */
    .topbar {
      position: sticky; top: 0; z-index: 30;
      display:flex; align-items:center; gap:8px;
      padding:10px 12px; background: var(--bg); border-bottom:1px solid var(--border-soft);
    }
    .toggle, .chip {
      border:1px solid var(--border); background: var(--btn); color: var(--fg);
      border-radius:999px; padding:8px 12px; cursor:pointer; font-weight:700;
      display:inline-flex; align-items:center; gap:.5rem;
    }
    .toggle:hover, .chip:hover { background: var(--btn-hover); }
    .title { flex:1 1 auto; text-align:center; font-weight:800; letter-spacing:.2px; }
    .status-pill { padding:4px 10px; border-radius:999px; background:color-mix(in srgb, var(--fg) 10%, transparent); color:var(--fg); font-size:12px; }

    /* REC badge */
    .rec-badge {
      display:none; align-items:center; gap:6px; margin-left:6px;
      font-weight:800; color:var(--danger); background:color-mix(in srgb, var(--danger) 15%, transparent);
      border:1px solid color-mix(in srgb, var(--danger) 30%, transparent); border-radius:999px; padding:3px 8px;
    }
    .rec-badge .dot {
      width:8px; height:8px; border-radius:50%; background:var(--danger);
      box-shadow:0 0 8px color-mix(in srgb, var(--danger) 70%, transparent);
      animation: recPulse 1s steps(2) infinite;
    }
    .rec-badge.on { display:inline-flex; }
    @keyframes recPulse { 50% { opacity: .35; } }

    /* Workspace */
    .workspace { flex:1 1 auto; min-height:0; display:flex; gap:0; }

    /* Sidebar (foldable) */
    .sidebar {
      width: 220px; min-width: 180px; max-width: 280px;
      background: var(--sidebar); border-right:1px solid var(--border-soft);
      display:flex; flex-direction:column; padding:10px; gap:12px;
      overflow:auto; transition: width .18s ease;
    }
    .sidebar.collapsed { width: 56px; min-width:56px; padding:10px 8px; }

    .group { display:flex; flex-direction:column; gap:6px; }
    .group-title {
      font-size:11px; color:var(--muted); padding:2px 4px;
      text-transform:uppercase; letter-spacing:.06em; transition:opacity .15s ease;
    }
    .sidebar.collapsed .group-title { opacity:0; height:0; overflow:hidden; padding:0; margin:0; }

    /* Buttons */
    .btn {
      display:flex; align-items:center; gap:.4rem;
      width:100%; padding:6px 8px; font-size:13px; border-radius:8px;
      background: var(--card); color: var(--fg); cursor:pointer;
      border:1px solid var(--border);
      transition: background .12s ease, border-color .12s ease;
      font-weight:700;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn .ico { width:16px; height:16px; flex-shrink:0; }
    .btn .label { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .sidebar.collapsed .btn { justify-content:center; padding:8px; }
    .sidebar.collapsed .btn .label { display:none; }

    /* Content */
    .content { flex:1 1 auto; min-width:0; display:flex; flex-direction:column; min-height:0; }

    /* Control panel */
    .control {
      background: var(--card-2); border-bottom:1px solid var(--border-soft);
      transition: height .2s ease, opacity .2s ease; overflow:hidden;
    }
    .control.collapsed { height:0; opacity:0; border-bottom-color: transparent; }
    .control.expanded  { height:auto; opacity:1; }
    .control-inner {
      display:flex; flex-direction:column; gap:12px;
      padding:12px 16px; max-height: 50vh; overflow:auto;
    }
    .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    label { display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted); }
    input[type="text"], input[type="number"], select {
      min-width: 160px; padding:8px; border-radius:8px; border:1px solid color-mix(in srgb, var(--fg) 20%, transparent);
      background: var(--input-bg); color: var(--fg);
    }
    input[type="checkbox"] { transform: scale(1.05); }
    .grow { flex:1 1 auto; min-width: 120px; }
    .section-title { margin: 4px 0 -4px; color:var(--muted); font-size:13px; }

    /* Secret input (Access Key) */
    .secret { display:flex; align-items:center; gap:8px; width: min(100%, 520px); }
    .secret input { flex:1 1 auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans Mono", monospace; }
    .reveal {
      border:1px solid var(--border); background: var(--btn); color: var(--fg);
      border-radius:8px; padding:8px 10px; cursor:pointer; font-weight:700; white-space:nowrap;
    }
    .reveal:hover{ background: var(--btn-hover); }

    /* Log area */
    .section-header { display:flex; align-items:center; gap:10px; flex-wrap:nowrap; }
    .section-header .section-title, .section-header .inline-toggle { margin:0; font-size:13px; line-height:1.25; }
    label.inline-toggle { display:inline-flex; flex-direction:row !important; align-items:center; gap:6px; white-space:nowrap; }
    label.inline-toggle input { transform:none; vertical-align:middle; margin:0; }
    #log {
      white-space: pre-wrap; background: var(--log-bg); color: var(--fg);
      padding:10px; border-radius:8px; min-height:80px; max-height:220px; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans Mono", monospace; font-size:12px;
      border:1px solid var(--border);
    }
    #btnTheme { padding: 4px 8px; }
    #btnTheme .ico { width: 14px; height: 14px; } 
    #themeLabel { font-size: 12px; } 

    /* Media */
    .media { flex:1 1 auto; min-height:0; display:flex; align-items:center; justify-content:center; padding:12px 16px; }
    video { width:100%; height:100%; max-width:1920px; background: var(--video-bg); border-radius:12px; object-fit:contain; }

    /* Responsive tweak */
    @media (max-width: 780px) {
      .sidebar { width: 164px; min-width:148px; }
      .sidebar.collapsed { width: 52px; min-width:52px; }
      .btn { padding:6px 8px; }
    }

    /* Tooltip when collapsed */
    .btn[data-tip] { position:relative; }
    .sidebar.collapsed .btn:hover::after {
      content: attr(data-tip);
      position: fixed; left: 60px; transform: translateY(-50%);
      background: var(--card); color: var(--fg); padding:4px 8px; border-radius:6px; font-size:12px; border:1px solid var(--border);
      pointer-events:none;
    }
  </style>
</head>
<body>
  <!-- Top header -->
  <div class="topbar">
    <button id="btnToggleMenu"  class="toggle" aria-expanded="true">☰ Menu</button>
    <button id="btnTogglePanel" class="toggle" aria-expanded="true">▦ Panel</button>
    <!-- REC badge with stats -->
    <span id="recBadge" class="rec-badge" aria-hidden="true"><span class="dot"></span>REC</span>
    <div class="title">TinyCam WebPlayer</div>
    <div class="status-pill" id="status">idle</div>

    <!-- Theme toggle -->
    <button id="btnTheme" class="chip" title="Toggle Theme">
      <svg class="ico" id="themeIcon" aria-hidden="true"><use href="#ico-moon"/></svg>
      <span id="themeLabel">Dark</span>
    </button>
  </div>

  <div class="workspace">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="group">
        <div class="group-title">Stream</div>
        <button id="sbStart" class="btn" data-tip="Start" title="Start">
          <svg class="ico" aria-hidden="true"><use href="#ico-play"/></svg><span class="label">Start</span>
        </button>
        <button id="sbStop" class="btn" data-tip="Stop" title="Stop">
          <svg class="ico" aria-hidden="true"><use href="#ico-stop"/></svg><span class="label">Stop</span>
        </button>
      </div>

      <div class="group">
        <div class="group-title">Recording</div>
        <button id="sbCapStart" class="btn" data-tip="Start Capture" title="Start Capture">
          <svg class="ico" aria-hidden="true"><use href="#ico-record"/></svg><span class="label">Start Capture</span>
        </button>
        <button id="sbCapStop" class="btn" data-tip="Stop Capture" title="Stop Capture">
          <svg class="ico" aria-hidden="true"><use href="#ico-stop"/></svg><span class="label">Stop Capture</span>
        </button>
        <button id="sbCapDownload" class="btn" data-tip="Download" title="Download">
          <svg class="ico" aria-hidden="true"><use href="#ico-download"/></svg><span class="label">Download</span>
        </button>
        <button id="sbCapClear" class="btn" data-tip="Clear Buffer" title="Clear Buffer">
          <svg class="ico" aria-hidden="true"><use href="#ico-broom"/></svg><span class="label">Clear Buffer</span>
        </button>
      </div>

      <div class="group">
        <div class="group-title">Config</div>
        <button id="sbSave" class="btn" data-tip="Save Config" title="Save Config">
          <svg class="ico" aria-hidden="true"><use href="#ico-save"/></svg><span class="label">Save Config</span>
        </button>
        <button id="sbLoad" class="btn" data-tip="Load Config" title="Load Config">
          <svg class="ico" aria-hidden="true"><use href="#ico-upload"/></svg><span class="label">Load Config</span>
        </button>
        <button id="sbClear" class="btn" data-tip="Clear Config" title="Clear Config">
          <svg class="ico" aria-hidden="true"><use href="#ico-trash"/></svg><span class="label">Clear Config</span>
        </button>
      </div>

      <div class="group">
        <div class="group-title">Logs</div>
        <button id="sbClearLogs" class="btn" data-tip="Clear Logs" title="Clear Logs">
          <svg class="ico" aria-hidden="true"><use href="#ico-broom"/></svg><span class="label">Clear Logs</span>
        </button>
        <button id="sbToggleDebug" class="btn" data-tip="Toggle Debug" title="Toggle Debug">
          <svg class="ico" aria-hidden="true"><use href="#ico-wrench"/></svg><span class="label">Toggle Debug</span>
        </button>
        <button id="sbToggleAutoScroll" class="btn" data-tip="Toggle Auto-scroll" title="Toggle Auto-scroll">
          <svg class="ico" aria-hidden="true"><use href="#ico-scroll"/></svg><span class="label">Toggle Auto-scroll</span>
        </button>
      </div>
    </aside>

    <!-- Content -->
    <section class="content">
      <!-- Control panel -->
      <section id="control" class="control expanded" aria-hidden="false">
        <div class="control-inner">
          <div class="row">
            <label>Host
              <input id="host" type="text" value="127.0.0.1" />
            </label>
            <label>Port
              <input id="port" type="number" value="8080" />
            </label>
            <label>SSL (wss)
              <input id="ssl" type="checkbox" />
            </label>
            <label class="grow">Access Key (base64)
              <div class="secret">
                <input id="accessKey" type="password" placeholder="paste accessKey (base64)" autocomplete="off" />
                <button id="btnShowKey" class="reveal" type="button" aria-pressed="false" title="Show/Hide">Show</button>
              </div>
            </label>
          </div>

          <div class="row">
            <label>Codec Hint
              <input id="codecHint" type="text" value="vp9" />
            </label>
            <label>Server Timeout (sec)
              <input id="srvTimeout" type="number" value="60" />
            </label>
            <label>Buffer Mode
              <select id="bufferMode">
                <option value="grow">grow (keep accumulating)</option>
                <option value="window">window (keep last N minutes)</option>
              </select>
            </label>
            <label>Window Minutes
              <input id="windowMinutes" type="number" value="5" />
            </label>
            <label>Debug Logs
              <input id="debug" type="checkbox" />
            </label>
            <label>Persist Access Key
              <input id="persistKey" type="checkbox" />
            </label>
            <label>Log Buffer Limit
              <input id="logLimit" type="number" value="1000" />
            </label>
          </div>

          <div class="section-title">Recording Options (MediaRecorder by default)</div>
          <div class="row">
            <label>Max bytes (MB)
              <input id="capMaxMB" type="number" value="300" />
            </label>
            <label>File name
              <input id="capFile" type="text" value="tinycam.webm" />
            </label>
            <label>MIME
              <input id="capMime" type="text" placeholder="(optional) e.g., video/webm" />
            </label>
            <div class="grow"></div>
          </div>

          <div class="section-header">
            <div class="section-title">Log</div>
            <label class="inline-toggle" title="Auto-scroll logs">
              <input id="autoScroll" type="checkbox" checked />Auto-scroll
            </label>
          </div>
          <div id="log"></div>
        </div>
      </section>

      <!-- Media -->
      <div class="media">
        <video id="video" controls muted playsinline></video>
      </div>
    </section>
  </div>

  <!-- TinyCam UMD -->
  <script>
(function (root, factory) {
  if (typeof define === 'function' && define.amd) { define([], factory); }
  else if (typeof module === 'object' && module.exports) { module.exports = factory(); }
  else { root.TinyCamPlayer = factory(); }
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // ========= Utils =========
  const enc = new TextEncoder();

  function nowIso(){ return new Date().toISOString().replace('T',' ').replace('Z',''); }
  function toU8(x){
    if (x instanceof Uint8Array) return x;
    if (x instanceof ArrayBuffer) return new Uint8Array(x);
    if (ArrayBuffer.isView(x)) return new Uint8Array(x.buffer, x.byteOffset, x.byteLength);
    if (typeof x === 'string') return enc.encode(x);
    return enc.encode(String(x));
  }
  function b64ToBuf(b64) {
    b64 = (b64||'').trim()
      .replace(/\u002B/g,'+').replace(/\u003d/gi,'=').replace(/\u002f/gi,'/')
      .replace(/-/g,'+').replace(/_/g,'/');
    const pad = b64.length % 4; if (pad) b64 += '='.repeat(4 - pad);
    const bin = typeof atob !== 'undefined' ? atob(b64) : Buffer.from(b64, 'base64').toString('binary');
    const u8 = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
    return u8.buffer;
  }
  function bufToB64(buf) {
    const u8 = toU8(buf);
    let bin=''; for (let i=0;i<u8.length;i++) bin += String.fromCharCode(u8[i]);
    if (typeof btoa !== 'undefined') return btoa(bin);
    return Buffer.from(bin, 'binary').toString('base64');
  }
  function randBytes(n){ const u=new Uint8Array(n); (crypto||window.crypto).getRandomValues(u); return u.buffer; }
  function u64beToBigInt(u8, off=0){ let v=0n; for (let i=0;i<8;i++){ v=(v<<8n)|BigInt(u8[off+i]); } return v; }

  async function importHmacKey(raw){
    const keyBuf = raw instanceof ArrayBuffer ? raw : toU8(raw).buffer;
    return crypto.subtle.importKey('raw', keyBuf, { name:'HMAC', hash:'SHA-256' }, false, ['sign']);
  }
  async function hmacSha256(keyRaw, data){
    const key = await importHmacKey(keyRaw);
    return crypto.subtle.sign('HMAC', key, toU8(data));
  }
  async function hkdfSha256(ikm, salt, info, length){
    const prkRaw = await hmacSha256(salt, ikm);
    const prk = await importHmacKey(prkRaw);

    const out = new Uint8Array(length);
    let t = new Uint8Array(0), written = 0, ctr = 1;
    while (written < length){
      const input = new Uint8Array(t.length + info.length + 1);
      input.set(t, 0); input.set(info, t.length); input[input.length-1] = ctr++;
      const block = new Uint8Array(await crypto.subtle.sign('HMAC', prk, input));
      const take = Math.min(block.length, length - written);
      out.set(block.subarray(0, take), written);
      written += take;
      t = block;
    }
    return out.buffer;
  }
  function makeAad(conn, exp, codec, w, h, fps){
    return enc.encode(`${conn}|${exp}|${codec}|${w}x${h}|${fps}`).buffer;
  }
  function mimeCandidates(codec){
    codec = (codec||'').toLowerCase(); const c=[];
    if (codec==='vp9' || codec==='vp09'){ c.push('video/webm; codecs="vp9"','video/webm; codecs="vp09.00.10.08"'); }
    else if (codec==='av1' || codec==='av01'){ c.push('video/webm; codecs="av1"','video/webm; codecs="av01"'); }
    else if (codec==='h264' || codec==='avc'){ c.push('video/mp4; codecs="avc1.42E01E"','video/mp4; codecs="avc1.4D401E"'); }
    else if (codec==='h265' || codec==='hevc'){ c.push('video/mp4; codecs="hvc1"','video/mp4; codecs="hev1"'); }
    else { c.push('video/webm; codecs="vp9"'); }
    return c;
  }
  function pickSupportedType(cands){ if (typeof MediaSource==='undefined') return null; for (const t of cands){ if (MediaSource.isTypeSupported(t)) return t; } return null; }

  // Storage helpers (localStorage with cookie fallback)
  function lsAvailable(){
    try { const k='__tc_ls_test__'; localStorage.setItem(k,'1'); localStorage.removeItem(k); return true; } catch { return false; }
  }
  function cookieSet(name, value, days=365){
    try {
      const maxAge = days*24*60*60;
      const secure = (typeof location!=='undefined' && location.protocol==='https:') ? '; Secure' : '';
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; Max-Age=${maxAge}; Path=/; SameSite=Lax${secure}`;
      return true;
    } catch { return false; }
  }
  function cookieGet(name){
    try{
      const n = encodeURIComponent(name) + '=';
      const parts = (document.cookie||'').split(/;\s*/);
      for (const p of parts){ if (p.startsWith(n)) return decodeURIComponent(p.slice(n.length)); }
    }catch{}
    return null;
  }
  function cookieDel(name){ try{ document.cookie = `${encodeURIComponent(name)}=; Max-Age=0; Path=/; SameSite=Lax`; }catch{} }
  function storageSetJSON(key, obj, days=365){
    const s = JSON.stringify(obj);
    if (lsAvailable()) { try { localStorage.setItem(key, s); return true; } catch {} }
    return cookieSet(key, s, days);
  }
  function storageGetJSON(key){
    if (lsAvailable()){
      try { const s = localStorage.getItem(key); if (s==null) return null; return JSON.parse(s); }
      catch {}
    }
    const c = cookieGet(key); if (!c) return null;
    try { return JSON.parse(c); } catch { return null; }
  }
  function storageDel(key){
    if (lsAvailable()) { try { localStorage.removeItem(key); } catch {} }
    cookieDel(key);
  }

  // ========= TinyCamPlayer =========
  class TinyCamPlayer {
    /**
     * @param {Object} opts
     * @param {HTMLVideoElement} opts.videoEl
     * @param {string} opts.host
     * @param {number} opts.port
     * @param {boolean} opts.ssl
     * @param {string} opts.accessKeyB64
     * @param {string} [opts.codecHint='vp9']
     * @param {number} [opts.serverTimeoutSec=60]
     * @param {boolean} [opts.debug=false]
     * @param {Function} [opts.onStatus]
     * @param {Function} [opts.onLog]
     * @param {Function} [opts.onError]
     * @param {Array}   [opts.logBuffer]
     * @param {number}  [opts.logBufferLimit=500]
     * @param {string}  [opts.storageKey='tinycam.player.v1']
     * @param {boolean} [opts.persistKey=false]
     * @param {boolean} [opts.autoLoad=false]
     * @param {boolean} [opts.autoSave=false]
     * @param {'grow'|'window'} [opts.bufferMode='grow']
     * @param {number}  [opts.windowMinutes=5]
     * @param {'mediarec'|'raw'} [opts.captureMode='mediarec']  // ★ default: mediarec
     */
    constructor(opts){
      if (!opts || !opts.videoEl) throw new Error('videoEl is required');
      this.video = opts.videoEl;
      this.host = opts.host || '127.0.0.1';
      this.port = typeof opts.port==='number' ? opts.port : 8080;
      this.ssl = !!opts.ssl;
      this.accessKeyB64 = opts.accessKeyB64 || '';
      this.codecHint = opts.codecHint || 'vp9';
      this.serverTimeoutSec = Math.max(2, +opts.serverTimeoutSec || 60);
      this.debug = !!opts.debug;

      this.onStatus = typeof opts.onStatus==='function' ? opts.onStatus : null;
      this.onLog = typeof opts.onLog==='function' ? opts.onLog : null;
      this.onError = typeof opts.onError==='function' ? opts.onError : null;

      this.logBuffer = Array.isArray(opts.logBuffer) ? opts.logBuffer : null;
      this.logBufferLimit = Number.isFinite(opts.logBufferLimit) ? Math.max(1, opts.logBufferLimit) : 500;

      this.storageKey = opts.storageKey || 'tinycam.player.v1';
      this.persistKey = !!opts.persistKey;
      this.autoLoad = !!opts.autoLoad;
      this.autoSave = !!opts.autoSave;

      this.bufferMode = (opts.bufferMode === 'window') ? 'window' : 'grow';
      this.windowMinutes = Number.isFinite(opts.windowMinutes) ? Math.max(1, opts.windowMinutes) : 5;

      // ★ Capture options
      this.captureMode = (opts.captureMode === 'raw') ? 'raw' : 'mediarec';

      // Internals
      this.ws = null; this.hbTimer=null; this.wdTimer=null; this.bufMon=null; this.trimTimer=null;
      this.lastRx = 0; this.firstBinarySeen=false; this.lastCounter = -1n;
      this.mediaSource=null; this.sourceBuffer=null; this.appendQueue=[];
      this.selectedType=null; this.containerMime='video/webm';

      this.aesKey=null; this.aadBuf=null; this.connId=null;

      // Raw capture store
      this.recording = false;
      this.captureParts = [];
      this.captureBytes = 0;
      this.recordMaxBytes = Infinity;
      this.captureMime = null;

      // MediaRecorder store
      this.mediaRecorder = null;
      this.recChunks = [];
      this._recStopPromise = null;

      this._recStartAt = null;
      this._recStopAt  = null;
      this._recBytes   = 0;

      this._boundHandlers = {
        onOpen: this._onOpen.bind(this),
        onMessage: this._onMessage.bind(this),
        onClose: this._onClose.bind(this),
        onError: this._onWsError.bind(this),
        onUpdateEnd: this._pump.bind(this),
      };

      if (this.autoLoad) {
        try { this.loadConfig(); } catch (e) { this._error(e); }
      }
    }

    // ---- Logging ----
    setDebug(flag){ this.debug = !!flag; }
    setStatus(s){ if (this.onStatus) try{ this.onStatus(s); }catch{} }
    _pushLogBuffer(line){
      if (!this.logBuffer || !this.debug) return;
      this.logBuffer.push(line);
      const over = this.logBuffer.length - this.logBufferLimit;
      if (over > 0) this.logBuffer.splice(0, over);
    }
    _log(...args){
      if (!this.debug) return;
      const line = `[${nowIso()}] ${args.map(a => typeof a==='string'?a:JSON.stringify(a)).join(' ')}`;
      this._pushLogBuffer(line);
      if (this.onLog) try{ this.onLog(line); }catch{} else console.log(line);
    }
    _error(e){ const err = e instanceof Error ? e : new Error(String(e)); if (this.onError) try{ this.onError(err); }catch{} else console.error(err); }

    // ---- Config persistence ----
    getConfig(opts={}) {
      const includeKey = !!(opts.includeKey ?? this.persistKey);
      const cfg = {
        host: this.host, port: this.port, ssl: this.ssl,
        codecHint: this.codecHint, serverTimeoutSec: this.serverTimeoutSec,
        debug: this.debug,
        bufferMode: this.bufferMode, windowMinutes: this.windowMinutes,
        captureMode: this.captureMode,
      };
      if (includeKey) cfg.accessKeyB64 = this.accessKeyB64;
      return cfg;
    }
    saveConfig(opts = {}) {
      const includeKey = !!(opts.includeKey ?? this.persistKey);
      const next = this.getConfig({ includeKey });
      if (!includeKey) {
        const prev = storageGetJSON(this.storageKey);
        if (prev && typeof prev.accessKeyB64 === 'string') {
        next.accessKeyB64 = prev.accessKeyB64;
        }
      }
      const ok = storageSetJSON(this.storageKey, next);
      if (!ok) throw new Error('Failed to persist config (storage blocked or full)');
      this._log('[cfg] saved', this.storageKey, includeKey ? '(with key)' : '(kept previous key)');
      return ok;
    }

    loadConfig(){
      const cfg = storageGetJSON(this.storageKey);
      if (!cfg) { this._log('[cfg] none'); return null; }
      if (typeof cfg.host==='string') this.host = cfg.host;
      if (typeof cfg.port==='number') this.port = cfg.port;
      if (typeof cfg.ssl==='boolean') this.ssl = cfg.ssl;
      if (typeof cfg.codecHint==='string') this.codecHint = cfg.codecHint;
      if (typeof cfg.serverTimeoutSec==='number' && cfg.serverTimeoutSec>=2) this.serverTimeoutSec = cfg.serverTimeoutSec;
      if (typeof cfg.debug==='boolean') this.debug = cfg.debug;
      if (typeof cfg.bufferMode==='string') this.bufferMode = (cfg.bufferMode==='window'?'window':'grow');
      if (typeof cfg.windowMinutes==='number' && cfg.windowMinutes>=1) this.windowMinutes = cfg.windowMinutes;
      if (typeof cfg.captureMode==='string') this.captureMode = (cfg.captureMode==='raw'?'raw':'mediarec');
      if (typeof cfg.accessKeyB64==='string' && this.persistKey) this.accessKeyB64 = cfg.accessKeyB64;
      this._log('[cfg] loaded', this.storageKey);
      return cfg;
    }
    clearConfig(){ storageDel(this.storageKey); this._log('[cfg] cleared', this.storageKey); }

    // ---- Buffer mode API ----
    setBufferMode(mode, windowMinutes){
      this.bufferMode = (mode==='window') ? 'window' : 'grow';
      if (Number.isFinite(windowMinutes) && windowMinutes>=1) this.windowMinutes = windowMinutes;
      this._log('[bufmode]', this.bufferMode, this.windowMinutes+'m');
    }
    setWindowMinutes(n){
      if (Number.isFinite(n) && n>=1) this.windowMinutes = n;
      this._log('[bufmode] windowMinutes=', this.windowMinutes);
    }

    // ---- Recorder helpers ----
    _pickRecorderMime(selectedType){
      if (typeof MediaRecorder === 'undefined') return null;
      const cands = [];
      const lower = (selectedType || '').toLowerCase();
      if (lower.includes('vp9')) cands.push('video/webm;codecs=vp9');
      if (lower.includes('av01') || lower.includes('av1')) cands.push('video/webm;codecs=av01.0.05M.08','video/webm;codecs=av01');
      cands.push('video/webm');
      for (const m of cands){
        try { if (MediaRecorder.isTypeSupported(m)) return m; } catch {}
      }
      return null;
    }

    // ---- Capture API ----
    startCapture(opts = {}) {
      this.recording = true;
      this.recordMaxBytes = Number.isFinite(opts.maxBytes) ? Math.max(1024*1024, opts.maxBytes) : Infinity;
      if (opts.mode) this.captureMode = (opts.mode === 'raw') ? 'raw' : 'mediarec';

      // ★ 통계 초기화
      this._recStartAt = performance.now();
      this._recStopAt  = null;
      this._recBytes   = 0;

      if (this.captureMode === 'mediarec' && typeof this.video.captureStream === 'function' && typeof MediaRecorder !== 'undefined') {
        const mime = opts.mime || this._pickRecorderMime(this.selectedType) || 'video/webm';
        this.captureMime = mime;
        try {
          const stream = this.video.captureStream();
          this.recChunks = [];
          this.mediaRecorder = new MediaRecorder(stream, { mimeType: mime });
          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size) {
              this.recChunks.push(e.data);
              this._recBytes += e.data.size;
            }
          };
          this._recStopPromise = new Promise((resolve) => { this.mediaRecorder.onstop = () => resolve(); });
          this.mediaRecorder.start(1000); 
          this._log('[rec] mediarec start mime=', mime);
          return;
        } catch (e) {
          this._log('[rec] mediarec not available, fallback to raw:', e?.toString?.()||String(e));
          this.captureMode = 'raw';
        }
      }

      // raw fallback
      this.captureMime = opts.mime || (this.containerMime || 'application/octet-stream');
      this._log('[rec] raw start mime=', this.captureMime, 'maxBytes=', this.recordMaxBytes);
    }

    async stopCapture() {
      if (!this.recording) return;
      this.recording = false;

      this._recStopAt = performance.now();

      if (this.captureMode === 'mediarec' && this.mediaRecorder) {
        try { if (this.mediaRecorder.state !== 'inactive') this.mediaRecorder.stop(); } catch {}
        if (this._recStopPromise) { try { await this._recStopPromise; } catch {} }
        this._log('[rec] mediarec stop');
        return;
      }
      this._log('[rec] raw stop (note: raw may not be directly playable)');
    }

    clearCapture(){ this.recChunks = []; this.captureParts = []; this.captureBytes = 0; this._log('[rec] cleared'); }

    getCaptureStats() {
      const started = this._recStartAt;
      if (!started) return { recording:false, mode:this.captureMode, bytes:0, elapsedSec:0 };

      const end = this.recording ? performance.now() : (this._recStopAt || performance.now());
      const bytes = (this.captureMode === 'mediarec') ? (this._recBytes || 0) : (this.captureBytes || 0);
      const elapsedSec = Math.max(0, (end - started) / 1000);

      return { recording: !!this.recording, mode: this.captureMode, bytes, elapsedSec };
    }

    async getCaptureBlob(){
      if (this.captureMode === 'mediarec'){
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive'){
          try { this.mediaRecorder.stop(); } catch {}
          if (this._recStopPromise) { try { await this._recStopPromise; } catch {} }
        }
        const mime = this.captureMime || 'video/webm';
        return new Blob(this.recChunks, { type: mime });
      }
      const mime = this.captureMime || 'application/octet-stream';
      return new Blob(this.captureParts, { type: mime });
    }

    async downloadCapture(filename='tinycam.webm'){
      const blob = await this.getCaptureBlob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); document.body.removeChild(a); }, 100);
      this._log('[rec] downloaded', filename, (blob.size/1024/1024).toFixed(2)+'MB');
    }

    // ---- Public playback ----
    async start(){
      if (!this.accessKeyB64) throw new Error('accessKeyB64 required');
      if (this.ws && this.ws.readyState === WebSocket.OPEN) return;

      this.setStatus('connecting…');
      if (this.autoSave) { try { this.saveConfig(); } catch(e){ this._error(e); } }

      const accessKey = b64ToBuf(this.accessKeyB64);
      const exp = Math.floor(Date.now()/1000) + 60;
      const token = await hmacSha256(accessKey, `stream:${exp}`);
      const tokenB64 = bufToB64(token);
      this._cnonce = randBytes(16);
      const cnonceB64 = bufToB64(this._cnonce);

      const url = `${this.ssl?'wss':'ws'}://${this.host}:${this.port}/stream?token=${encodeURIComponent(tokenB64)}&exp=${exp}&cnonce=${encodeURIComponent(cnonceB64)}`;
      this._log('[connect]', url);

      this._hello = null;
      this.lastRx = performance.now();
      this.firstBinarySeen=false;
      this.lastCounter = -1n;
      this._helloTimer = setTimeout(()=>{ try{ this.ws?.close(1001,'hello timeout'); }catch{} }, 20000);

      this.ws = new WebSocket(url);
      this.ws.binaryType = 'arraybuffer';
      this.ws.addEventListener('open', this._boundHandlers.onOpen);
      this.ws.addEventListener('message', this._boundHandlers.onMessage);
      this.ws.addEventListener('close', this._boundHandlers.onClose);
      this.ws.addEventListener('error', this._boundHandlers.onError);
    }

    stop(){
      try { this.ws?.close(1000,'bye'); } catch {}
      this._stopHeartbeat(); this._stopWatchdog(); this._stopBufferMonitor(); this._stopTrimTimer();
      this._resetMse();
      this.setStatus('idle');
      if (this.autoSave) { try { this.saveConfig(); } catch(e){ this._error(e); } }
    }

    isRunning(){ return !!this.ws && this.ws.readyState === WebSocket.OPEN; }

    // ---- WS internals ----
    async _onOpen(){
      this._log('[ws] open');
      this._startHeartbeat();
      this._startWatchdog();
      if (this.debug) this._startBufferMonitor();
      this._startTrimTimer();
    }

    async _onMessage(ev){
      this.lastRx = performance.now();

      if (typeof ev.data === 'string'){
        if (!this._hello){
          let hello;
          try { hello = JSON.parse(ev.data); } catch { this._log('[hello] invalid json'); return; }
          if (hello.type !== 'hello'){ this._log('[hello] unexpected', hello); return; }
          clearTimeout(this._helloTimer);
          this._hello = hello;

          const serverNonceBuf = b64ToBuf(hello.snonce);
          const conn = String(hello.conn);
          const w = Number(hello.w|0), h = Number(hello.h|0), fps = Number(hello.fps|0);
          const codec = String(hello.codec || this.codecHint).toLowerCase();
          const expSrv = Number(hello.exp|0);
          if (!Number.isFinite(expSrv)) { this._log('[hello] invalid exp'); this.ws.close(); return; }

          this.connId = new Uint8Array(b64ToBuf(conn)).subarray(0,4);
          const cU8 = toU8(this._cnonce), sU8 = toU8(serverNonceBuf);
          const salt = new Uint8Array(cU8.length + sU8.length);
          salt.set(cU8, 0); salt.set(sU8, cU8.length);
          const accessKey = b64ToBuf(this.accessKeyB64);
          const info = enc.encode('tinycam hkdf v1');
          const sessionKey = await hkdfSha256(accessKey, salt.buffer, info, 32);
          this.aesKey = await crypto.subtle.importKey('raw', sessionKey, { name:'AES-GCM' }, false, ['decrypt']);
          this.aadBuf = makeAad(conn, expSrv, codec, w, h, fps);

          const type = pickSupportedType(mimeCandidates(codec));
          if (!type){ this._log('[mse] no supported type for codec:', codec); this.ws.close(1003,'unsupported'); return; }
          this.selectedType = type;
          this.containerMime = (type.split(';')[0] || 'video/webm');
          this._log('[mse] type:', type);
          try { await this._ensureMse(type); } catch(e){ this._log('[mse] init error', e?.toString?.()||String(e)); this.ws.close(); return; }

          this.ws.send(JSON.stringify({ type:'start', conn, exp: expSrv }));
          this._log('[start] sent');

          (async () => {
            const deadline = performance.now() + (this.serverTimeoutSec * 1000);
            while (!this.firstBinarySeen && this.ws && this.ws.readyState===WebSocket.OPEN && performance.now() < deadline) await new Promise(r=>setTimeout(r, 50));
            if (!this.firstBinarySeen && this.ws && this.ws.readyState===WebSocket.OPEN){
              this._log('[health] first binary frame timeout');
              try { this.ws.close(1001,'first frame timeout'); } catch {}
            }
          })();

          this.setStatus(`streaming ${w}x${h}@${fps} ${codec}`);
        } else {
          this._log('[text]', ev.data);
        }
        return;
      }

      try { await this._handleBinary(ev.data); }
      catch (e){ this._log('[ws] binary handle error:', e?.toString?.()||String(e)); }
    }

    _onClose(ev){
      this._log(`[ws] close: code=${ev.code} reason="${ev.reason}" wasClean=${ev.wasClean}`);
      this._stopHeartbeat(); this._stopWatchdog(); this._stopBufferMonitor(); this._stopTrimTimer();
      this.setStatus('closed');
      if (this.autoSave) { try { this.saveConfig(); } catch(e){ this._error(e); } }
    }
    _onWsError(){ this._error(new Error('WebSocket error')); }

    // ---- Binary/crypto ----
    async _handleBinary(arrBuf){
      const u8 = new Uint8Array(arrBuf);
      if (u8.length < 28){ this._log('[ws] short frame', u8.length); return; }

      const nonce = u8.subarray(0,12);
      const tag   = u8.subarray(12,28);
      const ct    = u8.subarray(28);

      if (this.connId && (nonce[0]!==this.connId[0] || nonce[1]!==this.connId[1] || nonce[2]!==this.connId[2] || nonce[3]!==this.connId[3])){
        this._log('[crypto] connId mismatch in nonce'); return;
      }
      const ctr = u64beToBigInt(u8, 4);
      if (this.lastCounter >= 0 && ctr <= this.lastCounter){
        this._log(`[crypto] non-increasing counter: ${ctr} <= ${this.lastCounter}`); return;
      }
      this.lastCounter = ctr;

      const ctTag = new Uint8Array(ct.length + 16);
      ctTag.set(ct, 0); ctTag.set(tag, ct.length);

      let plain;
      try{
        plain = await crypto.subtle.decrypt(
          { name:'AES-GCM', iv: nonce, additionalData: this.aadBuf, tagLength: 128 },
          this.aesKey,
          ctTag
        );
      }catch(e){
        this._log('[crypto] decrypt error:', e?.toString?.()||String(e)); return;
      }

      // raw capture only
      if (this.recording && this.captureMode === 'raw'){
        const seg = new Uint8Array(plain);
        this.captureParts.push(seg);
        this.captureBytes += seg.byteLength;
        while (this.captureBytes > this.recordMaxBytes && this.captureParts.length){
          const dropped = this.captureParts.shift();
          this.captureBytes -= dropped.byteLength;
        }
      }

      // debug fps
      if (this.debug){
        this._binCount = (this._binCount||0) + 1;
        const now = performance.now();
        if (!this._lastFpsLog) this._lastFpsLog = now - 2000;
        if (now - this._lastFpsLog > 2000){
          const fps = this._binCount * 1000 / (now - this._lastFpsLog);
          this._log(`[ws] binary fps~ ${fps.toFixed(1)}`);
          this._lastFpsLog = now; this._binCount = 0;
        }
      }

      this._enqueue(new Uint8Array(plain));
      if (!this.firstBinarySeen){
        this.firstBinarySeen = true;
        this._log('[stream] first decrypted frame appended');
        this.video.play().catch(()=>{});
        setTimeout(()=>{ 
          try { if (this.video.paused && this.video.buffered?.length) {
            const end = this.video.buffered.end(this.video.buffered.length-1);
            this.video.currentTime = Math.max(0, end - 0.1);
            this.video.play().catch(()=>{});
          }} catch {}
        }, 500);
      }
    }

    // ---- MSE & append ----
    _resetMse(){
      try { if (this.sourceBuffer && this.mediaSource?.readyState==='open') this.sourceBuffer.abort(); } catch {}
      try { if (this.mediaSource) this.mediaSource.endOfStream(); } catch {}
      this.sourceBuffer=null; this.mediaSource=null; this.appendQueue.length=0;
    }
    _enqueue(buf){ this.appendQueue.push(buf); this._maybeTrimBuffer(); this._pump(); }
    _pump(){
      if (!this.sourceBuffer || this.appendQueue.length===0 || this.sourceBuffer.updating) return;
      const chunk = this.appendQueue.shift();
      try{ this.sourceBuffer.appendBuffer(chunk); }
      catch(e){
        this._log('[mse] append error:', e?.toString?.()||String(e));
        if (e.name==='QuotaExceededError' && this.video.buffered?.length && !this.sourceBuffer.updating){
          const keep = Math.max(0, this.video.currentTime - 30);
          try { this.sourceBuffer.remove(0, keep); this.appendQueue.unshift(chunk); } catch {}
        }
      }
    }
    async _ensureMse(type){
      return new Promise((resolve,reject)=>{
        this._resetMse();
        this.mediaSource = new MediaSource();
        const url = URL.createObjectURL(this.mediaSource);
        this.video.src = url;
        this.mediaSource.addEventListener('sourceopen', ()=>{
          try{
            this.sourceBuffer = this.mediaSource.addSourceBuffer(type);
            this.sourceBuffer.mode='sequence';
            this.sourceBuffer.addEventListener('updateend', this._boundHandlers.onUpdateEnd);
            resolve();
          }catch(e){ reject(e); }
        }, { once:true });
      });
    }

    // ---- Buffer trimming (window mode) ----
    _maybeTrimBuffer(){
      if (this.bufferMode !== 'window') return;
      if (!this.sourceBuffer || this.sourceBuffer.updating) return;
      const br = this.video.buffered; if (!br || br.length===0) return;

      const winSec = this.windowMinutes * 60;
      const end = br.end(br.length - 1);
      const keepFrom = Math.max(0, end - winSec);
      const safety = 1.0; // margin
      const removeEnd = Math.max(0, keepFrom - safety);

      if (removeEnd > 0){
        try {
          this.sourceBuffer.remove(0, removeEnd);
          this._log('[trim] remove 0 ~', removeEnd.toFixed(2));
        } catch(e){
          this._log('[trim] error', e?.toString?.()||String(e));
        }
      }
    }
    _startTrimTimer(){ this._stopTrimTimer(); this.trimTimer = setInterval(()=>this._maybeTrimBuffer(), 1000); }
    _stopTrimTimer(){ if (this.trimTimer){ clearInterval(this.trimTimer); this.trimTimer=null; } }

    // ---- Health ----
    _startHeartbeat(){
      this._stopHeartbeat();
      const hbSec = Math.max(1, Math.floor(this.serverTimeoutSec / 2));
      this.hbTimer = setInterval(()=>{
        try { this.ws?.send(JSON.stringify({ type:'ping', ts: Date.now()/1000 })); } catch {}
      }, hbSec*1000);
      this._log(`[health] heartbeat every ${hbSec}s (server timeout ${this.serverTimeoutSec}s)`);
    }
    _stopHeartbeat(){ if (this.hbTimer){ clearInterval(this.hbTimer); this.hbTimer=null; } }

    _startWatchdog(){
      this._stopWatchdog();
      this.wdTimer = setInterval(()=>{
        const idle = (performance.now() - this.lastRx)/1000;
        if (idle > this.serverTimeoutSec){
          this._log(`[health] inactivity ${idle.toFixed(1)}s > ${this.serverTimeoutSec}s: closing`);
          try { this.ws?.close(1001, 'client watchdog inactivity'); } catch {}
          this._stopWatchdog();
        }
      }, 1000);
    }
    _stopWatchdog(){ if (this.wdTimer){ clearInterval(this.wdTimer); this.wdTimer=null; } }

    _startBufferMonitor(){
      if (!this.debug) return;
      this._stopBufferMonitor();
      this.bufMon = setInterval(()=>{
        try {
          const br = this.video.buffered;
          const ranges = [];
          for (let i=0;i<br.length;i++) ranges.push([br.start(i).toFixed(2), br.end(i).toFixed(2)]);
          this._log('[buf]', 'ct=', this.video.currentTime.toFixed(2), 'ranges=', JSON.stringify(ranges));
        } catch {}
      }, 2000);
    }
    _stopBufferMonitor(){ if (this.bufMon){ clearInterval(this.bufMon); this.bufMon=null; } }
  }

  return TinyCamPlayer;
}));

</script>
  <script>
    (function(){
      const UI_KEY = 'tinycam.ui';

      // Topbar
      const btnToggleMenu  = document.getElementById('btnToggleMenu');
      const btnTogglePanel = document.getElementById('btnTogglePanel');
      const recBadge = document.getElementById('recBadge');
      const statusEl  = document.getElementById('status');

      // Theme
      const root = document.documentElement;
      const btnTheme = document.getElementById('btnTheme');
      const themeIcon = document.getElementById('themeIcon');
      const themeLabel = document.getElementById('themeLabel');
      const savedTheme = localStorage.getItem('tinycam.theme'); // 'light' | 'dark' | null
      const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
      const initialTheme = savedTheme ? savedTheme : (prefersLight ? 'light' : 'dark');
      applyTheme(initialTheme);
      btnTheme.addEventListener('click', () => {
        const next = root.classList.contains('theme-light') ? 'dark' : 'light';
        applyTheme(next);
        try { localStorage.setItem('tinycam.theme', next); } catch {}
      });
      function applyTheme(mode) {
        root.classList.toggle('theme-light', mode === 'light');
        themeLabel.textContent = mode === 'light' ? 'Light' : 'Dark';
        themeIcon.firstElementChild?.setAttribute('href', mode === 'light' ? '#ico-sun' : '#ico-moon');
      }

      // Layout
      const sidebar = document.getElementById('sidebar');
      const control = document.getElementById('control');

      // Sidebar buttons
      const sbStart = document.getElementById('sbStart');
      const sbStop = document.getElementById('sbStop');
      const sbCapStart = document.getElementById('sbCapStart');
      const sbCapStop = document.getElementById('sbCapStop');
      const sbCapDownload = document.getElementById('sbCapDownload');
      const sbCapClear = document.getElementById('sbCapClear');
      const sbSave = document.getElementById('sbSave');
      const sbLoad = document.getElementById('sbLoad');
      const sbClear = document.getElementById('sbClear');
      const sbClearLogs = document.getElementById('sbClearLogs');
      const sbToggleDebug = document.getElementById('sbToggleDebug');
      const sbToggleAutoScroll = document.getElementById('sbToggleAutoScroll');

      // Inputs
      const host       = document.getElementById('host');
      const port       = document.getElementById('port');
      const ssl        = document.getElementById('ssl');
      const accessKey  = document.getElementById('accessKey');
      const btnShowKey = document.getElementById('btnShowKey');
      const codecHint  = document.getElementById('codecHint');
      const srvTimeout = document.getElementById('srvTimeout');
      const bufferMode = document.getElementById('bufferMode');
      const windowMin  = document.getElementById('windowMinutes');
      const debug      = document.getElementById('debug');
      const persistKey = document.getElementById('persistKey');
      const logLimit   = document.getElementById('logLimit');

      const capMaxMB   = document.getElementById('capMaxMB');
      const capFile    = document.getElementById('capFile');
      const capMime    = document.getElementById('capMime');

      const autoScroll = document.getElementById('autoScroll');
      const logEl      = document.getElementById('log');
      const video      = document.getElementById('video');

      // State
      const logs = [];
      let player = null;
      let ui = loadUi() || { sidebarCollapsed:false, panelOpen:true };

      // ----- UI helpers -----
      function loadUi(){ try { return JSON.parse(localStorage.getItem(UI_KEY) || ''); } catch { return null; } }
      function saveUi(){ try { localStorage.setItem(UI_KEY, JSON.stringify(ui)); } catch {} }
      function setMenuCollapsed(collapsed){
        ui.sidebarCollapsed = !!collapsed; saveUi();
        sidebar.classList.toggle('collapsed', ui.sidebarCollapsed);
        btnToggleMenu.setAttribute('aria-expanded', (!ui.sidebarCollapsed).toString());
      }
      function setPanelOpen(open){
        ui.panelOpen = !!open; saveUi();
        control.classList.toggle('expanded', ui.panelOpen);
        control.classList.toggle('collapsed', !ui.panelOpen);
        control.setAttribute('aria-hidden', ui.panelOpen ? 'false' : 'true');
        btnTogglePanel.setAttribute('aria-expanded', ui.panelOpen ? 'true' : 'false');
      }

      // Show/Hide key
      btnShowKey.addEventListener('click', ()=>{
        const isPwd = accessKey.type === 'password';
        accessKey.type = isPwd ? 'text' : 'password';
        btnShowKey.textContent = isPwd ? 'Hide' : 'Show';
        btnShowKey.setAttribute('aria-pressed', (!isPwd).toString());
      });

      // Init UI
      setMenuCollapsed(!!ui.sidebarCollapsed);
      setPanelOpen(!!ui.panelOpen);

      // Logs
      function renderLogs(newLine=false){
        logEl.textContent = logs.join('\n');
        if (!autoScroll.checked) return;
        const nearBottom = (logEl.scrollHeight - logEl.scrollTop - logEl.clientHeight) < 40;
        if (nearBottom || newLine) logEl.scrollTop = logEl.scrollHeight;
      }
      function clearLogs(){ logs.length = 0; renderLogs(); }

      // ----- REC badge timer / stats -----
      let recTimerId = null;
      function fmtTime(sec) {
        sec = Math.floor(sec);
        const s = (sec % 60).toString().padStart(2,'0');
        const m = Math.floor(sec / 60) % 60;
        const h = Math.floor(sec / 3600);
        return h ? `${h}:${m.toString().padStart(2,'0')}:${s}` : `${m}:${s}`;
      }
      function fmtBytes(bytes) {
        if (bytes < 1024) return bytes + 'B';
        const kb = bytes / 1024;
        if (kb < 1024) return kb.toFixed(1) + 'KB';
        const mb = kb / 1024;
        if (mb < 1024) return mb.toFixed(1) + 'MB';
        const gb = mb / 1024;
        return gb.toFixed(2) + 'GB';
      }
      function updateRecBadge() {
        if (!player || typeof player.getCaptureStats !== 'function') return;
        const st = player.getCaptureStats();
        if (!st.recording) return;
        recBadge.innerHTML = `<span class="dot"></span>REC&nbsp;${fmtTime(st.elapsedSec)}&nbsp;${fmtBytes(st.bytes)}`;
      }
      function setRec(on){
        recBadge.classList.toggle('on', !!on);
        recBadge.setAttribute('aria-hidden', (!on).toString());
        if (on) {
          if (recTimerId) clearInterval(recTimerId);
          updateRecBadge();
          recTimerId = setInterval(updateRecBadge, 1000);
        } else {
          if (recTimerId) clearInterval(recTimerId);
          recTimerId = null;
          recBadge.innerHTML = `<span class="dot"></span>REC`;
        }
      }

      // Build player options
      function getOpts(){
        const limit = Math.max(1, parseInt(logLimit.value || '1000', 10));
        return {
          videoEl: video,
          host: host.value.trim(),
          port: parseInt(port.value || '8080', 10),
          ssl: !!ssl.checked,
          accessKeyB64: accessKey.value.trim(),
          codecHint: codecHint.value.trim() || 'vp9',
          serverTimeoutSec: Math.max(2, parseInt(srvTimeout.value || '60', 10)),
          debug: !!debug.checked,
          logBuffer: logs,
          logBufferLimit: limit,
          storageKey: 'tinycam.player.v1',
          persistKey: !!persistKey.checked,
          autoLoad: false,
          autoSave: true,
          bufferMode: bufferMode.value,
          windowMinutes: Math.max(1, parseInt(windowMin.value || '5', 10)),
          onStatus: (s)=>{ statusEl.textContent = s; },
          onLog: (line)=>{ if (debug.checked){ logs.push(line); const over=logs.length - limit; if (over>0) logs.splice(0, over); renderLogs(true);} },
          onError: (e)=>{ console.error(e); },
        };
      }
      function applyFormToPlayer(p){
        if (!p) return;
        p.host = host.value.trim();
        p.port = parseInt(port.value || '8080', 10);
        p.ssl  = !!ssl.checked;
        p.accessKeyB64 = accessKey.value.trim();
        p.codecHint = codecHint.value.trim() || 'vp9';
        p.serverTimeoutSec = Math.max(2, parseInt(srvTimeout.value || '60', 10));
        p.setDebug(!!debug.checked);
        p.logBufferLimit = Math.max(1, parseInt(logLimit.value || '1000', 10));
        p.persistKey = !!persistKey.checked;
        p.setBufferMode(bufferMode.value, Math.max(1, parseInt(windowMin.value || '5', 10)));
      }
      function syncFormFromConfig(cfg){
        if (!cfg) return;
        if (typeof cfg.host==='string') host.value = cfg.host;
        if (typeof cfg.port==='number') port.value = cfg.port;
        if (typeof cfg.ssl==='boolean') ssl.checked = cfg.ssl;
        if (typeof cfg.codecHint==='string') codecHint.value = cfg.codecHint;
        if (typeof cfg.serverTimeoutSec==='number') srvTimeout.value = cfg.serverTimeoutSec;
        if (typeof cfg.debug==='boolean') debug.checked = cfg.debug;
        if (typeof cfg.bufferMode==='string') bufferMode.value = (cfg.bufferMode==='window'?'window':'grow');
        if (typeof cfg.windowMinutes==='number') windowMin.value = cfg.windowMinutes;
        if (typeof cfg.accessKeyB64==='string' && persistKey.checked) accessKey.value = cfg.accessKeyB64;
      }

      // ===== Actions =====
      sbStart.addEventListener('click', async ()=>{
        if (!player){ player = new TinyCamPlayer(getOpts()); }
        else { applyFormToPlayer(player); }
        clearLogs();
        try { await player.start(); }
        catch (e){ console.error(e); alert('Start error: ' + (e.message || e)); }
      });

      sbStop.addEventListener('click', async ()=>{
        if (!player) return;
        if (player.recording) { try { await player.stopCapture(); } catch {} setRec(false); }
        player.stop();
      });

      sbCapStart.addEventListener('click', ()=>{
        if (!player) return alert('Start the player first.');
        const maxMB = Math.max(1, parseInt(capMaxMB.value || '300', 10));
        const maxBytes = maxMB * 1024 * 1024;
        const mime = capMime.value.trim() || undefined;
        player.startCapture({ maxBytes, mime, mode: 'mediarec' });
        setRec(true);
      });

      sbCapStop.addEventListener('click', async ()=>{
        if (!player) return;
        await player.stopCapture();
        setRec(false);
      });

      sbCapDownload.addEventListener('click', async ()=>{
        if (!player) return;
        const name = (capFile.value || 'tinycam.webm').trim();
        await player.downloadCapture(name);
      });

      sbCapClear.addEventListener('click', ()=>{
        if (!player) return;
        player.clearCapture();
        if (!player.recording) setRec(false);
      });

      sbSave.addEventListener('click', ()=>{
        if (!player) player = new TinyCamPlayer(getOpts());
        else applyFormToPlayer(player);
        try { player.saveConfig({ includeKey: !!persistKey.checked }); alert('Saved.'); }
        catch(e){ alert('Save failed: ' + (e.message || e)); }
      });

      sbLoad.addEventListener('click', ()=>{
        if (!player) player = new TinyCamPlayer(getOpts());
        const cfg = player.loadConfig();
        syncFormFromConfig(cfg);
        applyFormToPlayer(player);
      });

      sbClear.addEventListener('click', ()=>{
        if (!player) player = new TinyCamPlayer(getOpts());
        player.clearConfig(); alert('Cleared.');
      });

      sbClearLogs.addEventListener('click', ()=>{ logs.length = 0; renderLogs(); });

      sbToggleDebug.addEventListener('click', ()=>{
        debug.checked = !debug.checked;
        if (player) player.setDebug(!!debug.checked);
      });

      sbToggleAutoScroll.addEventListener('click', ()=>{
        autoScroll.checked = !autoScroll.checked;
      });

      // Live reactions
      bufferMode.addEventListener('change', ()=>{ if (player) player.setBufferMode(bufferMode.value, parseInt(windowMin.value||'5',10)); });
      windowMin.addEventListener('change', ()=>{ if (player) player.setWindowMinutes(parseInt(windowMin.value||'5',10)); });

      // Top toggles
      btnToggleMenu.addEventListener('click', ()=> setMenuCollapsed(!ui.sidebarCollapsed));
      btnTogglePanel.addEventListener('click', ()=> setPanelOpen(!ui.panelOpen));
    })();
  </script>
</body>
</html>
